import {
    configureModelElement,
    configureViewerOptions,
    loadDefaultModules,
    LocalModelSource,
    PolylineEdgeView,
    SEdge,
    SGraph,
    SGraphView,
    SNode,
    TYPES,
    ProjectedViewportView,
    ViewportRootElement,
    viewportModule,
    defaultModule,
    modelSourceModule,
    boundsModule,
    buttonModule,
    commandPaletteModule,
    contextMenuModule,
    decorationModule,
    edgeEditModule,
    edgeLayoutModule,
    expandModule,
    exportModule,
    fadeModule,
    hoverModule,
    labelEditModule,
    labelEditUiModule,
    moveModule,
    openModule,
    routingModule,
    selectModule,
    undoRedoModule,
    updateModule,
    zorderModule,
    SLabel,
    SLabelView,
    SRoutingHandle,
    SRoutingHandleView,
    EdgeRouterRegistry,
    ManhattanEdgeRouter,
    ManhattanEllipticAnchor,
    RECTANGULAR_ANCHOR_KIND,
    ManhattanRectangularAnchor,
    ELLIPTIC_ANCHOR_KIND,
    ManhattanDiamondAnchor,
    DIAMOND_ANCHOR_KIND,
    SRoutableElement,
    DefaultAnchors,
    RoutedPoint,
    translatePoint,
    SConnectableElement,
} from "sprotty";

import {almostEquals, Bounds, Point} from "sprotty-protocol/lib/utils/geometry";

const margin = 1e-5;
const includes = (b: Bounds, p: Point, m: number = margin) =>
    p.x >= b.x + m &&
    p.x <= b.x + b.width - m &&
    p.y >= b.y + m &&
    p.y <= b.y + b.height - m;

export class CustomManhattanEdgeRouter extends ManhattanEdgeRouter {
    static k = "mh";
    get kind() {
        return CustomManhattanEdgeRouter.k;
    }

    protected getOptions(edge: any): any {
        return {
            standardDistance: 5,
            minimalPointDistance: 3,
            selfEdgeOffset: 3,
        };
    }

    // Source: https://github.com/eclipse-sprotty/sprotty/blob/master/packages/sprotty/src/features/routing/manhattan-edge-router.ts#L44
    // Modified to adjust source and target
    route(edge: SRoutableElement): RoutedPoint[] {
        if (!edge.source || !edge.target) return [];
        const routedCorners = this.createRoutedCorners(edge);
        const sourceRefPoint =
            routedCorners[0] ||
            translatePoint(
                Bounds.center(edge.target.bounds),
                edge.target.parent,
                edge.parent
            );
        const sourceAnchor = this.getTranslatedAnchor(
            edge.source,
            sourceRefPoint,
            edge.parent,
            edge,
            edge.sourceAnchorCorrection
        );
        const targetRefPoint =
            routedCorners[routedCorners.length - 1] ||
            translatePoint(
                Bounds.center(edge.source.bounds),
                edge.source.parent,
                edge.parent
            );
        const targetAnchor = this.getTranslatedAnchor(
            edge.target,
            targetRefPoint,
            edge.parent,
            edge,
            edge.targetAnchorCorrection
        );
        if (!sourceAnchor || !targetAnchor) return [];
        const routedPoints: RoutedPoint[] = [];
        if (!routedCorners[0] || !includes(edge.source.bounds, routedCorners[0], -margin))
            routedPoints.push({kind: "source", ...sourceAnchor});
        routedPoints.push(...routedCorners);
        if (
            !routedCorners[routedCorners.length - 1] ||
            !includes(
                edge.target.bounds,
                routedCorners[routedCorners.length - 1],
                -margin
            )
        )
            routedPoints.push({kind: "target", ...targetAnchor});
        return routedPoints;
    }

    // Source: https://github.com/eclipse-sprotty/sprotty/blob/master/packages/sprotty/src/features/routing/manhattan-edge-router.ts#L183
    // Modified to use `includes` which adds a small error margin in order to not delete points generated by ELK
    cleanupRoutingPoints(
        edge: SRoutableElement,
        routingPoints: Point[],
        updateHandles: boolean,
        addRoutingPoints: boolean
    ): void {
        const sourceAnchors = new DefaultAnchors(edge.source!, edge.parent, "source");
        const targetAnchors = new DefaultAnchors(edge.target!, edge.parent, "target");
        if (
            this.resetRoutingPointsOnReconnect(
                edge,
                routingPoints,
                updateHandles,
                sourceAnchors,
                targetAnchors
            )
        )
            return;

        // delete leading RPs inside the bounds of the source
        for (let i = 0; i < routingPoints.length; ++i)
            if (includes(sourceAnchors.bounds, routingPoints[i])) {
                routingPoints.splice(0, 1);
                if (updateHandles) {
                    this.removeHandle(edge, -1);
                }
            } else {
                break;
            }
        // delete trailing RPs inside the bounds of the target
        for (let i = routingPoints.length - 1; i >= 0; --i)
            if (includes(targetAnchors.bounds, routingPoints[i])) {
                routingPoints.splice(i, 1);
                if (updateHandles) {
                    this.removeHandle(edge, i);
                }
            } else {
                break;
            }
        if (routingPoints.length >= 2) {
            const options = this.getOptions(edge);
            for (let i = routingPoints.length - 2; i >= 0; --i) {
                if (
                    Point.manhattanDistance(routingPoints[i], routingPoints[i + 1]) <
                    options.minimalPointDistance
                ) {
                    routingPoints.splice(i, 2);
                    --i;
                    if (updateHandles) {
                        this.removeHandle(edge, i - 1);
                        this.removeHandle(edge, i);
                    }
                }
            }
        }
        if (addRoutingPoints) {
            this.addAdditionalCorner(
                edge,
                routingPoints,
                sourceAnchors,
                targetAnchors,
                updateHandles
            );
            this.addAdditionalCorner(
                edge,
                routingPoints,
                targetAnchors,
                sourceAnchors,
                updateHandles
            );
            this.manhattanify(edge, routingPoints);
        }
    }
}
export class CustomManhattanEllipticAnchor extends ManhattanEllipticAnchor {
    get kind() {
        return CustomManhattanEdgeRouter.k + ":" + ELLIPTIC_ANCHOR_KIND;
    }
}
export class CustomManhattanRectangularAnchor extends ManhattanRectangularAnchor {
    get kind() {
        return CustomManhattanEdgeRouter.k + ":" + RECTANGULAR_ANCHOR_KIND;
    }
}
export class CustomManhattanDiamondAnchor extends ManhattanDiamondAnchor {
    get kind() {
        return CustomManhattanEdgeRouter.k + ":" + DIAMOND_ANCHOR_KIND;
    }
}
